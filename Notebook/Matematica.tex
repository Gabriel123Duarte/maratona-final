\chapter{Matemática}


\section{Eliminação de Gauss com o XOR}

Retorna o valor máximo de xor que é possível se obter fazendo xor entre os elementos da array. \\	
Pode ser necessário o ull ou bitset.
\begin{multicols}{2}
	\begin{lstlisting}

int len(ll x){
	int ans = 0;
	while(x){
		ans++;
		x >>= 1;
	}
	return ans;
}
	
ll gaussxor(ll arr[], int n){
	vector<ll> buckets[65];
	for(int i = 0; i < n; i++)
		buckets[len(arr[i])].pb(arr[i]);
	
	vector<ll> modified;
	for(int i = 64; i; i--){
		if(buckets[i].size()){
			modified.pb(buckets[i][0]);
			for(int j = 1; j < buckets[i].size(); j++){
				ll temp = buckets[i][0] ^ buckets[i][j];
				buckets[len(temp)].pb(temp);
			}
		}
	}
	
	// Ans = maximum xor subset
	ll ans = 0;
	for(auto m : modified)
		if(ans < ans^m)
			ans ^= m;
	return ans;
}
	\end{lstlisting}
\end{multicols}
\section{Fórmula de Legendre}

Dados um inteiro $n$ e um primo $p$, calcula o expoente da maior potência de $p$ que divide $n!$ em $O(logn)$.
\begin{multicols}{2}
	\begin{lstlisting}
ll legendre(ll n, ll p){
	ll ans = 0;
	ll prod = p;
	while(prod <= n){
		ans += n/prod;
		prod *= p;
	}
	return ans;
}
	\end{lstlisting}
\end{multicols}

\section{Número de fatores primos de N!}

Dado um N encontra quantos fatores o N! possui
\begin{multicols}{2}
	\begin{lstlisting}
// Sieve of Eratosthenes to mark all prime number
// in array prime as 1
void sieve(int n, bool prime[])
{
	// Initialize all numbers as prime
	for (int i=1; i<=n; i++)
	prime[i] = 1;
	
	// Mark composites
	prime[1] = 0;
	for (int i=2; i*i<=n; i++)
	{
		if (prime[i])
		{
			for (int j=i*i; j<=n; j += i)
			prime[j] = 0;
		}
	}
}

// Returns the highest exponent of p in n!
int expFactor(int n, int p)
{
	int x = p;
	int exponent = 0;
	while ((n/x) > 0)
	{
		exponent += n/x;
		x *= p;
	}
	return exponent;
}

// Returns the no of factors in n!
ll countFactors(int n)
{
	// ans stores the no of factors in n!
	ll ans = 1;
	
	// Find all primes upto n
	bool prime[n+1];
	sieve(n, prime);
	
	// Multiply exponent (of primes) added with 1
	for (int p=1; p<=n; p++)
	{
		// if p is a prime then p is also a
		// prime factor of n!
		if (prime[p]==1)
		ans *= (expFactor(n, p) + 1);
	}
	
	return ans;
}

\end{lstlisting}
\end{multicols}

\section{Trailing zeros in factorial}

\begin{multicols}{2}
	\begin{lstlisting}
int findTrailingZeros(int  n){
	// Initialize result
	int count = 0;
	
	// Keep dividing n by powers of 5 and update count
	for (int i=5; n/i>=1; i *= 5)
		count += n/i;
	
	return count;
}
\end{lstlisting}
\end{multicols}


\section{Número de divisores de N!}

Dado um N encontra quantos divisores o N! possui
\begin{multicols}{2}
	\begin{lstlisting}

// allPrimes[] stores all prime numbers less
// than or equal to n.
vector<ull> allPrimes;

// Fills above vector allPrimes[] for a given n
void sieve(int n)
{
	// Create a boolean array "prime[0..n]" and
	// initialize all entries it as true. A value
	// in prime[i] will finally be false if i is
	// not a prime, else true.
	vector<bool> prime(n+1, true);
	
	// Loop to update prime[]
	for (int p=2; p*p<=n; p++)
	{
		// If prime[p] is not changed, then it
		// is a prime
		if (prime[p] == true)
		{
			// Update all multiples of p
			for (int i=p*2; i<=n; i += p)
			prime[i] = false;
		}
	}
	
	// Store primes in the vector allPrimes
	for (int p=2; p<=n; p++)
	if (prime[p])
	allPrimes.push_back(p);
}

// Function to find all result of factorial number
ull factorialDivisors(ull n)
{
	sieve(n);  // create sieve
	
	// Initialize result
	ull result = 1;
	
	// find exponents of all primes which divides n
	// and less than n
	for (int i=0; i < allPrimes.size(); i++)
	{
		// Current divisor
		ull p = allPrimes[i];
		
		// Find the highest power (stored in exp)'
		// of allPrimes[i] that divides n using
		// Legendre's formula.
		ull exp = 0;
		while (p <= n)
		{
			exp = exp + (n/p);
			p = p*allPrimes[i];
		}
		
		// Multiply exponents of all primes less
		// than n
		result = result*(exp+1);
	}
	
	// return total divisors
	return result;
}
\end{lstlisting}
\end{multicols}

\section{Grundy Number}
Faz o xor de todos os números grundy de todas as pilhas, se for diferente de 0 ganha o jogo.
\begin{multicols}{2}
	\begin{lstlisting}

ll mex(unordered_set<ll> st){
	ll ans = 0;
	while(st.count(ans)) ans++;
	return ans;
}

ll grundy(int x){
	if(x perde jogo)
		return 0;
		
	unordered_set<ll> st;
	for(int i = 0; i < l; i++)
		st.insert(grundy(novoX)); // Transicoes
	return mex(st);
}
\end{lstlisting}
\end{multicols}

\section{Baby-Step Giant-Step para Logaritmo Discreto}
Resolve a equação $a^ = b(modm)$ em $O(sqrt(m)log m)$. Retorna -1 se não há solução.
\begin{multicols}{2}
\begin{lstlisting}
template <typename T>
T baby(T a, T b, T m){
	a %= m; b %= m;
	T n = (T)sqrt(m+0.0)+1;
	T an = 1;
	for(T i = 0; i < n; i++)
		an = (an*a)%m;
	map<T,T> vals;
	for(T i = 1, cur = an; i <= n; i++){
		if(!vals.count(cur))
			vals[cur] = 1;
		cur = (cur*an)%m;
	}
	for(T i = 0, cur = b; i <= n; i++){
		if(!vals.count(cur)){
			T ans = vals[cur] * n - i;
			if(ans < m)
				return ans;
		}
		cur = (cur * a) % m);
	}
	return -1;
}

\end{lstlisting}
\end{multicols}

\section{Fórmulas úteis}


\begin{itemize}
\itemsep0em
\item Soma dos n primeiros fibonacci: $f(n+2)-1$.
\item Soma dos n primeiros fibonacci ao quadrado: $f(n)*f(n+1)$.
\item Soma dos quadrados de todos números de 1 até n:   $n*(n+1)*(2n+1)/6$.
\end{itemize}

