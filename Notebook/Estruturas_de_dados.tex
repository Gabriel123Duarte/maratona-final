\chapter{Estruturas de dados}

\section{Prefix Sum 1D}

Soma $a..b$ em $O(1)$.
\begin{multicols}{2}
\begin{lstlisting}
#define MAXN 1000
int arr[MAXN];
int prefix[MAXN];

void build(int n){
	prefix[0] = 0;
	for(int i = 1; i <= n; i++) // arr 1-indexado
		prefix[i] = prefix[i-1]+arr[i];
}

int get(int a, int b){
	return prefix[b] - prefix[a-1];
}

\end{lstlisting}
\end{multicols}


\section{BIT - Fenwick Tree}

Soma $1..N$ e update em ponto em $O(log n)$.
\begin{multicols}{2}
	\begin{lstlisting}
#define MAXN 10000
int bit[MAXN];
void update(int x, int val){
	for(; x < MAXN; x+=x&-x)
		bit[x] += val;
}
int get(int x){
	int ans = 0;
	for(; x; x-=x&-x)
		ans += bit[x];
	return ans;
}
	\end{lstlisting}
\end{multicols}

\section{BIT - Fenwick Tree 2D}

Soma um subretÃ¢ngulo e update em ponto em $O(log^2n)$.
\begin{multicols}{2}
	\begin{lstlisting}
#define MAXN 1000
int bit[MAXN][MAXN];

void update(int x, int y, int val){
	for(; x < MAXN; x+=x&-x)
		for(int j = y; j < MAXN; j+=j&-j)
			bit[x][j] += val;
}

int get(int x, int y){
	int ans = 0;
	for(; x; x-=x&-x)
		for(int j = y; j; j-=j&-j)
			ans += bit[x][j];
	return ans;
}

int get(int x1, int y1, int x2, int y2){
	return get(x2, y2) - get(x1-1, y2) - get(x2, y1-1) + get(x1-1, y1-1);
}

	\end{lstlisting}
\end{multicols}

\section{Segment Tree 2D}

\begin{multicols}{2}
	\begin{lstlisting}

#define MAXN 1030

int tree[4*MAXN][4*MAXN];

void buildy(int idxx, int lx, int rx, int idxy, int ly, int ry){
	if(ly == ry){
		if(lx == rx)
			tree[idxx][idxy] = 0; // Valor inicial
		else
			tree[idxx][idxy] = tree[idxx*2][idxy] + tree[idxx*2+1][idxy];
		return;
	}
	buildy(idxx, lx, rx, idxy*2, ly, (ly+ry)/2);
	buildy(idxx, lx, rx, idxy*2+1, (ly+ry)/2+1, ry);
	tree[idxx][idxy] = tree[idxx][idxy*2] + tree[idxx][idxy*2+1];
}

void buildx(int idx, int lx, int rx, int ly, int ry){
	if(lx != rx){
		buildx(idx*2, lx, (lx+rx)/2, ly, ry);
		buildx(idx*2+1, (lx+rx)/2+1, rx, ly, ry);
	}
	buildy(idx, lx, rx, 1, ly, ry);
}

int gety(int idxx, int idxy, int ly, int ry, int y1, int y2){
	if(ly > y2 || ry < y1)
		return 0;
	if(ly >= y1 && ry <= y2)
		return tree[idxx][idxy];
	return gety(idxx, idxy*2, ly, (ly+ry)/2, y1, y2) + gety(idxx, idxy*2+1, (ly+ry)/2+1, ry, y1, y2);
}

int getx(int idxx, int lx, int rx, int idxy, int ly, int ry, int x1, int x2, int y1, int y2){
	if(lx > x2 || rx < x1)
		return 0;
	if(lx >= x1 && rx <= x2)
		return gety(idxx, idxy, ly, ry, y1, y2);
	return getx(idxx*2, lx, (lx+rx)/2, idxy, ly, ry, x1, x2, y1, y2) +
	getx(idxx*2+1, (lx+rx)/2+1, rx, idxy, ly, ry, x1, x2, y1, y2);
}

void updatey(int idxx, int lx, int rx, int idxy, int ly, int ry, int py, int val){
	if(ly > py || ry < py)
	return;
	if(ly == ry){
		if(lx == rx)
			tree[idxx][idxy] += val;
		else
			tree[idxx][idxy] = tree[idxx*2][idxy] + tree[idxx*2+1][idxy];
		return;
	}
	updatey(idxx, lx, rx, idxy*2, ly, (ly+ry)/2, py, val);
	updatey(idxx, lx, rx, idxy*2+1, (ly+ry)/2+1, ry, py, val);
	tree[idxx][idxy] = tree[idxx][idxy*2] + tree[idxx][idxy*2+1];
}

void updatex(int idxx, int lx, int rx, int idxy, int ly, int ry, int px, int py, int val){
	if(lx > px || rx < px)
	return;
	if(lx != rx){
		updatex(idxx*2, lx, (lx+rx)/2, idxy, ly, ry, px, py, val);
		updatex(idxx*2+1, (lx+rx)/2+1, rx, idxy, ly, ry, px, py, val);
	}
	updatey(idxx, lx, rx, idxy, ly, ry, py, val);
}

	\end{lstlisting}
\end{multicols}