\chapter{Grafos}

\section{Ford Fulkerson}

Encontra o fluxo máximo em $O(|\textit{f*}|E)$.
\begin{multicols}{2}
	\begin{lstlisting}
#define MAXN 100000
struct node{
	int v, f, c;
	node(){}
	node(int _v, int _f, int _c){
		v = _v, f = _f, c = _c;
	}
};

vector<node> edges;
vector<int> graph[MAXN];
int vis[MAXN];
int cnt;

void add(int u, int v, int c){
	edges.pb(node(v, 0, c));
	graph[u].pb(edges.size()-1);
	edges.pb(node(u, 0, 0));
	graph[v].pb(edges.size()-1);
}

int dfs(int s, int t, int f){
	if(s == t)
	return f;
	vis[s] = cnt;
	for(auto e : graph[s]){
		if(vis[edges[e].v] < cnt && edges[e].c-edges[e].f > 0){
			if(int x = dfs(edges[e].v, t, min(f,edges[e].c-edges[e].f))){
				edges[e].f += x;
				edges[e^1].f -= x;
				return x;
			}
		}
	}
	return 0;
}

int maxFlow(int s, int t){
	int ans = 0;
	cnt = 1;
	memset(vis, 0, sizeof vis);
	while(int flow = dfs(s, t, 1<<30)){
		ans += flow;
		cnt++;
	}
	return ans;
}
	\end{lstlisting}
\end{multicols}


\section{Edmonds Karp}

Troca a $dfs()$ do Ford Fulkerson por uma $bfs()$ e o fluxo máximo fica em $O(VE^2)$.

\section{Dinic}

Encontra o fluxo máximo em $O(V^2E)$.
\begin{multicols}{2}
	\begin{lstlisting}
#define MAXN 5050
#define inf 0x3f3f3f3f

struct node{
	int v, f, c;
	node(){}
	node(int _v, int _f, int _c){
		v = _v, f = _f, c = _c;
	}
};
vector<node> edges;
vector<int> graph[MAXN];
int dist[MAXN];
int ptr[MAXN];

void add(int u, int v, int c){
	edges.pb(node(v, 0, c));
	graph[u].pb(edges.size()-1);
	edges.pb(node(u, 0, 0));
	graph[v].pb(edges.size()-1);
}

bool bfs(int s, int t){
	memset(dist, inf, sizeof dist);
	dist[s] = 0;
	queue<int> q;
	q.push(s);
	
	while(!q.empty()){
		int u = q.front(); q.pop();
		for(auto e : graph[u]){
			if(dist[edges[e].v] == inf && edges[e].c-edges[e].f > 0){
				q.push(edges[e].v);
				dist[edges[e].v] = dist[u] + 1;
			}
		}
	}
	
	return dist[t] != inf;
}

int dfs(int s, int t, int f){
	if(s == t)
	return f;
	for(int &i = ptr[s]; i < graph[s].size(); i++){
		int e = graph[s][i];
		if(dist[edges[e].v] == dist[s]+1 && edges[e].c-edges[e].f > 0){
			if(int x = dfs(edges[e].v, t, min(f, edges[e].c-edges[e].f))){
				edges[e].f += x;
				edges[e^1].f -= x;
				return x;
			}
		}
	}
	
	return 0;
}

int maxFlow(int s, int t){
	int ans = 0;
	while(bfs(s, t)){
		memset(ptr, 0, sizeof ptr);
		while(int f = dfs(s, t, inf))
		ans += f;
	}
	return ans;
}
\end{lstlisting}
\end{multicols}

\section{Tarjan}

Componentes fortemente conexos em $O(V+E)$.
\begin{multicols}{2}
	\begin{lstlisting}
#define MAXN 100100
vector<int> graph[MAXN];
stack<int> st;
int in[MAXN], low[MAXN], vis[MAXN], cnt;
int sccs;

void dfs(int u){
	in[u] = low[u] = cnt++;
	vis[u] = 1;
	st.push(u);
	
	for(auto v : graph[u]){
		if(!vis[v]){
			dfs(v);
			low[u] = min(low[u], low[v]);
		}
		else
			low[u] = min(low[u], in[v]);
	}
	if(low[u] == in[u]){
		sccs++;
		int x;
		do{
			x = st.top();
			st.pop();
			in[x] = 1<<30;
		}while(x != u);
	}
}

void tarjan(int n){
	cnt = sccs = 0;
	memset(vis, 0, sizeof vis);
	while(!st.empty())
		st.pop();
	for(int i = 0; i < n; i++)
		if(!vis[i])
			dfs(i);
}
\end{lstlisting}
\end{multicols}

\section{Pontos de articulação}

Complexidade $O(V+E)$.
\begin{multicols}{2}
	\begin{lstlisting}
#define MAXN 100100
vector<int> graph[MAXN];
int in[MAXN], low[MAXN], vis[MAXN], cnt;
vector<int> points;

void dfs(int u int root){
	in[u] = low[u] = cnt++;
	vis[u] = 1;
	int total = 0;	
	bool ok = 0;
	for(auto v : graph[u]){
		if(!vis[v]){
			dfs(v, root);
			low[u] = min(low[u], low[v]);
			total++;
			if(low[v] >= in[u])
				ok = 1;
			// if(low[v] > in[u]) u-v eh uma ponte
		}
		else
			low[u] = min(low[u], in[v]);
		
	}
	if(u == root && total >= 2 || ok && u != root)
		points.pb(u);
}

void getPoints(int n){
	cnt = 0;
	points.clear();
	memset(vis, 0, sizeof vis);
	for(int i = 0; i < n; i++)
		if(!vis[i])
			dfs(i, i);
}
\end{lstlisting}
\end{multicols}
